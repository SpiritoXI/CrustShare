# 文件上传限制说明

## 当前限制

### Vercel 免费层限制

- **请求体大小限制**: 4.5 MB
- **执行时间限制**: 10 秒（最大可配置到 60 秒）
- **内存限制**: 1024 MB

这意味着：
- 超过 4.5 MB 的文件会返回 `413 (Content Too Large)` 错误
- 即使配置了 `maxDuration`，也无法增加请求体大小限制

## 解决方案

### 1. 前端文件大小检查（已实现）

在上传前检查文件大小，如果超过限制直接拒绝并提示用户：

```typescript
const MAX_FILE_SIZE = 4.5 * 1024 * 1024; // 4.5MB

if (file.size > MAX_FILE_SIZE) {
  toast.error(`文件超过大小限制（4.5MB）`);
  return;
}
```

### 2. 上传失败清理（已实现）

如果上传失败（包括 413 错误），自动从文件列表中删除该文件：

```typescript
try {
  // 上传文件
  const result = await proxy.upload(file, options);
} catch (err) {
  // 上传失败，从列表中删除
  deleteFile(fileId);
  toast.error('上传失败');
}
```

### 3. 错误提示优化（已实现）

对于 413 错误，提供更友好的错误提示：

```typescript
if (errorMessage.includes('413') || errorMessage.includes('Content Too Large')) {
  toast.error(
    `文件超过 Vercel 免费层限制（4.5MB），请升级到付费版或使用分片上传`
  );
}
```

## 升级方案

### 方案 A：升级到 Vercel Pro（推荐）

Vercel Pro 计划提供更高的限制：
- 请求体大小限制：4.5 MB（与免费层相同）
- 执行时间限制：60 秒
- 更多功能：带宽、函数调用次数等

**注意**：即使升级到 Pro，请求体大小限制仍然是 4.5 MB。

### 方案 B：实现分片上传

将大文件分成多个小片段上传，然后在服务端合并：

**优点**：
- 不受单次请求体大小限制
- 支持断点续传
- 上传进度更精确

**缺点**：
- 需要修改前端和后端代码
- 需要额外的存储空间来保存临时分片
- 实现复杂度较高

**实现步骤**：

1. 前端：
   - 将文件分成多个 4MB 的片段
   - 逐个上传片段
   - 上传完成后通知后端合并

2. 后端：
   - 接收每个片段并保存到临时存储
   - 所有片段上传完成后，合并成一个完整文件
   - 将完整文件上传到 CrustFiles.io

### 方案 C：使用对象存储直传

将文件直接上传到对象存储（如 AWS S3、Upstash Blob Storage），绕过 Vercel 的限制：

**优点**：
- 不受 Vercel 限制
- 可以支持超大文件上传
- 利用对象存储的 CDN 加速

**缺点**：
- 需要配置对象存储
- 需要处理预签名 URL
- 需要额外的存储费用

**实现步骤**：

1. 前端请求后端生成预签名 URL
2. 前端直接使用预签名 URL 上传到对象存储
3. 上传完成后通知后端，后端再将文件上传到 CrustFiles.io

## 当前实现的功能

✅ **前端文件大小检查** - 在上传前检查文件是否超过 4.5MB
✅ **上传失败清理** - 上传失败后自动从列表中删除文件
✅ **友好的错误提示** - 针对不同错误类型提供清晰的提示
✅ **Vercel 配置优化** - 增加 API 函数的最大执行时间和内存

## 测试建议

1. **小文件测试** (< 4.5MB)
   - 应该能成功上传
   - 文件应该正确添加到列表

2. **边界测试** (~4.5MB)
   - 测试刚好 4.5MB 的文件
   - 测试略大于 4.5MB 的文件

3. **错误处理测试**
   - 模拟网络错误
   - 模拟 413 错误
   - 确认错误提示清晰
   - 确认失败后文件被删除

## 未来计划

- [ ] 实现分片上传功能
- [ ] 支持断点续传
- [ ] 集成对象存储直传
- [ ] 添加上传队列管理
- [ ] 支持批量上传
